---
title: "Simulation study across no. images and grid size"
author: "Joel Eliason"
date: "2024-02-19"
output: html_document
---

```{r}
library(tidyverse)
devtools::load_all()
set.seed(2020)

grid <- expand_grid(
  num_images=c(2,5,10,15,20,25,30),
  num_grids=c(20,30,40,50,75,100)
)

num_images <- 5
num_grids <- 20
purrr::pmap_df(grid,\(num_images,num_grids) {
  print(num_images)
  print(num_grids)
  SS <- num_grids
  dd <- 2 # spatial dimension
  n <- SS^2 # number of locations
  q <- 2 # number of outcomes
  k <- 2 # number of spatial factors used to make the outcomes
  p <- 1 # number of covariates
  
  xlocs <- seq(0, 1, length.out=SS)
  coords <- expand.grid(list(xlocs, xlocs)) %>%
    as.data.frame()
  
  clist <- 1:q %>% lapply(function(i) coords %>%
                            mutate(mv_id=i) %>%
                            as.matrix())
  
  philist <- c(1, 1) # spatial decay for each factor
  
  # cholesky decomp of covariance matrix
  LClist <- 1:k %>% lapply(function(i) t(chol(
    #exp(- philist[i] * as.matrix(dist(clist[[i]])))))) #^2 + diag(nrow(clist[[i]]))*1e-5))))
    bipps:::Cov_matern(clist[[i]], clist[[i]], 1, philist[i], 0.5, 0, T, 10))))
  
  # generating the factors
  WW <- lapply(1:num_images,\(j) {
    wlist <- 1:k %>% lapply(function(i) LClist[[i]] %*% rnorm(n))
  
    # factor matrix
    do.call(cbind, wlist)
  })
  
  
  # factor loadings
  Lambda <- matrix(0, q, ncol(WW[[1]]))
  diag(Lambda) <- runif(k, 1, 2)
  Lambda[lower.tri(Lambda)] <- runif(sum(lower.tri(Lambda)), -1, 1)
  Lambda[2,2] <- .5
  
  # nuggets
  tau.sq <- rep(.01, q)
  TTsq <- matrix(1, nrow=n) %x% matrix(tau.sq, ncol=length(tau.sq))
  # measurement errors
  # double check these
  EE <- ( rnorm(n*length(tau.sq)) %>% matrix(ncol=length(tau.sq)) ) * TTsq^.5
  
  XX <- lapply(1:num_images,\(j) {
    1:p %>% lapply(function(i) rnorm(n, 0, .1)) %>% do.call(cbind, .)
  })
  Beta <- matrix(rnorm(p*q), ncol=q) * 0
  
  # outcome matrix, fully observed
  linear_predictor <- lapply(1:num_images,\(i) XX[[i]] %*% Beta + WW[[i]] %*% t(Lambda))
  YY_full <- lapply(1:num_images,\(i) {
    y <- matrix(0, ncol=q, nrow=nrow(linear_predictor[[i]]))
    y <- lapply(1:q,\(j) {
      rpois(n, exp(linear_predictor[[i]][,j]))
    })
    y <- do.call(cbind,y)
  })
  
  YY <- YY_full
  
  simdata <- coords %>%
    cbind(data.frame(Outcome_full=YY_full,
                     Outcome_obs = YY))
  
  
  mcmc_keep <- 1000
  mcmc_burn <- 5000
  mcmc_thin <- 1
  
  
  mesh_total_time <- system.time({
    meshout <- multi_bipps(YY, family="poisson", XX, coords, k = 2,
                        block_size=25,
                        n_samples = mcmc_keep, n_burn = mcmc_burn, n_thin = mcmc_thin,
                        n_threads = 1,
                        starting=list(lambda = Lambda, beta=Beta, phi=1),
                        prior = list(btmlim= .01, toplim=1e3, phi=c(.1, 20), nu=c(.5, .5)),
                        settings = list(adapting=T, saving=F, ps=T, hmc=0),
                        verbose=10,
                        debug=list(sample_beta=F, sample_tausq=F,
                                   sample_theta=F, sample_w=T, sample_lambda=T,
                                   verbose=T, debug=F)
    )})
})
```


```{r}
plot_cube <- function(cube_mcmc, q, k, name="Parameter"){
  par(mar=c(2.5,2,1,1), mfrow=c(q,k))
  for(i in 1:q){
    for(j in 1:k){
      cube_mcmc[i, j,] %>% plot(type='l', main="{name} {i}, {j}" %>% glue::glue())
    }
  }
}

# chain plots
plot_cube(meshout$theta_mcmc, 1, k, "theta")
plot_cube(meshout$lambda_mcmc, q, k, "Lambda")
plot_cube(meshout$beta_mcmc, p, q, "Beta")
```

